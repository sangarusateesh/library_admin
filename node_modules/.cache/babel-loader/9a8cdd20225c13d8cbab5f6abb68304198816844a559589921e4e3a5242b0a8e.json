{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDimensionsSelector } from '../dimensions/gridDimensionsSelectors';\nexport const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nexport const GRID_ID_AUTOGENERATED = Symbol('mui.id_autogenerated');\nexport const buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexport function checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI X: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport const createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  const dataRowIdToIdLookup = {};\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToIdLookup,\n    dataRowIdToModelLookup\n  };\n};\nexport const getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport const getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths\n}) => {\n  const cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp\n  });\n};\nexport const isAutoGeneratedRow = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexport const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  const validDescendants = [];\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n    const childDescendants = getTreeNodeDescendants(tree, child, skipAutoGeneratedRows);\n    for (let j = 0; j < childDescendants.length; j += 1) {\n      validDescendants.push(childDescendants[j]);\n    }\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexport const updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates\n}) => {\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI X: Unable to prepare a partial update if a full update is not applied yet.');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...(previousCache.updates.actions.insert ?? [])],\n      modify: [...(previousCache.updates.actions.modify ?? [])],\n      remove: [...(previousCache.updates.actions.remove ?? [])]\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n  const dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n    const oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n  return {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  const pinnedRows = gridPinnedRowsSelector(apiRef);\n  const topPinnedRowsHeight = pinnedRows?.top?.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0) || 0;\n  const bottomPinnedRowsHeight = pinnedRows?.bottom?.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  return `var(--DataGrid-overlayHeight, ${2 * dimensions.rowHeight}px)`;\n}","map":{"version":3,"names":["_extends","gridPinnedRowsSelector","gridDimensionsSelector","GRID_ROOT_GROUP_ID","GRID_ID_AUTOGENERATED","Symbol","buildRootGroup","type","id","depth","groupingField","groupingKey","isAutoGenerated","children","childrenFromPath","childrenExpanded","parent","checkGridRowIdIsValid","row","detailErrorMessage","Error","JSON","stringify","join","getRowIdFromRowModel","rowModel","getRowId","createRowsInternalCache","rows","loading","rowCount","updates","dataRowIdToModelLookup","dataRowIdToIdLookup","i","length","model","push","rowsBeforePartialUpdates","loadingPropBeforePartialUpdates","rowCountPropBeforePartialUpdates","getTopLevelRowCount","tree","rowCountProp","rootGroupNode","Math","max","footerId","getRowsStateFromCache","apiRef","loadingProp","previousTree","previousTreeDepths","cache","current","caches","unProcessedTree","treeDepths","unProcessedTreeDepths","dataRowIds","unProcessedDataRowIds","groupingName","applyStrategyProcessor","groupingParamsWithHydrateRows","unstable_applyPipeProcessors","actions","insert","modify","remove","idToActionLookup","totalRowCount","totalTopLevelRowCount","isAutoGeneratedRow","rowNode","getTreeNodeDescendants","parentId","skipAutoGeneratedRows","node","validDescendants","child","childDescendants","j","updateCacheWithNewRows","previousCache","uniqueUpdates","Map","forEach","update","has","set","get","partialUpdates","alreadyAppliedActionsToRemove","partialRow","actionAlreadyAppliedToRow","_action","oldRow","actionTypeWithActionsToRemove","Object","keys","actionType","idsToRemove","filter","calculatePinnedRowsHeight","pinnedRows","topPinnedRowsHeight","top","reduce","acc","value","unstable_getRowHeight","bottomPinnedRowsHeight","bottom","getMinimalContentHeight","dimensions","state","rowHeight"],"sources":["/home/satheesh/Documents/React/lcommerce/node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { gridPinnedRowsSelector } from './gridRowsSelector';\nimport { gridDimensionsSelector } from '../dimensions/gridDimensionsSelectors';\nexport const GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nexport const GRID_ID_AUTOGENERATED = Symbol('mui.id_autogenerated');\nexport const buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexport function checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI X: The data grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nexport const getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexport const createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  const dataRowIdToIdLookup = {};\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    dataRowIdToIdLookup[id] = id;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToIdLookup,\n    dataRowIdToModelLookup\n  };\n};\nexport const getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexport const getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths\n}) => {\n  const cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIdToIdLookup: cache.dataRowIdToIdLookup,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return _extends({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp\n  });\n};\nexport const isAutoGeneratedRow = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexport const getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  const validDescendants = [];\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutoGeneratedRow(tree[child])) {\n      validDescendants.push(child);\n    }\n    const childDescendants = getTreeNodeDescendants(tree, child, skipAutoGeneratedRows);\n    for (let j = 0; j < childDescendants.length; j += 1) {\n      validDescendants.push(childDescendants[j]);\n    }\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexport const updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates\n}) => {\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI X: Unable to prepare a partial update if a full update is not applied yet.');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...(previousCache.updates.actions.insert ?? [])],\n      modify: [...(previousCache.updates.actions.modify ?? [])],\n      remove: [...(previousCache.updates.actions.remove ?? [])]\n    },\n    idToActionLookup: _extends({}, previousCache.updates.idToActionLookup)\n  };\n  const dataRowIdToModelLookup = _extends({}, previousCache.dataRowIdToModelLookup);\n  const dataRowIdToIdLookup = _extends({}, previousCache.dataRowIdToIdLookup);\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      delete dataRowIdToIdLookup[id];\n      return;\n    }\n    const oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = _extends({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n    dataRowIdToIdLookup[id] = id;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n  return {\n    dataRowIdToModelLookup,\n    dataRowIdToIdLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexport function calculatePinnedRowsHeight(apiRef) {\n  const pinnedRows = gridPinnedRowsSelector(apiRef);\n  const topPinnedRowsHeight = pinnedRows?.top?.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0) || 0;\n  const bottomPinnedRowsHeight = pinnedRows?.bottom?.reduce((acc, value) => {\n    acc += apiRef.current.unstable_getRowHeight(value.id);\n    return acc;\n  }, 0) || 0;\n  return {\n    top: topPinnedRowsHeight,\n    bottom: bottomPinnedRowsHeight\n  };\n}\nexport function getMinimalContentHeight(apiRef) {\n  const dimensions = gridDimensionsSelector(apiRef.current.state);\n  return `var(--DataGrid-overlayHeight, ${2 * dimensions.rowHeight}px)`;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}